---
title: "2024-02-06 Getting Started with R"
author: "Austin K Lien"
date: "2024-02-06"
output: 
  html_document:
    # code_folding: hide
    df_print: "kable"
    toc: yes
    toc_float: yes
    toc_depth: 4
    toc_width: 1
    fig_retina: 2
    number_sections: no
    highlight: pygments
    theme: sandstone
    
  pdf_document:
    toc: yes
    toc_depth: '4'
---

# R and Rstudio 

**R is a programming language and environment for statistical and graphics.**

**RStudio is a powerful integrated development environment (IDE) specifically designed for R programming and provides a user-friendly interface that makes coding, data analysis, and report generation more efficient.**

Let's explore the key components of the RStudio environment:

- The **Source pane** (top left quadrant) is the main coding area
    - This is the central area where you write and edit your R code and where your R Markdown scripts take shape.
    - Output is also displayed here if Global Options for R Markdown are set to "Show output inline"
    
- The **Console pane** (bottom left quadrant) can be used to type and execute short interactive R commands such as installing packages.
  - This also serves as a place to monitor various messages, warnings, and errors generated during code execution.
  
- The **Environment pane** (top right quadrant) provides a snapshot of the current workspace, showing a list of R objects that are currently loaded into the R session.
  - Dataframes appear as tables that store data in rows and columns
    - these are fundamental structures for working with datasets
  - Variables are displayed with their name, type, and values.
  - Additional objects that can be displayed here are: lists, functions, vectors and matrices, factors, strings, and other user-defined objects.
    - *We will get into all this later*
    
- The **Output pane** (bottom left quadrant) serves as a central location for displaying various plots and visualizations generated during the R session in addition to other crucial information.
  - The file tab allows you to explore the files and directories in your current **working directory**.
  - The plots tab is dedicated to displaying graphical outputs generated by plotting functions.
  - The packages tab provides a list of installed packages in your R environment.
  - The help tab is where you can access documentation and help files for R functions, packages, and other topics
    - A shortcut for help is to highlight the specific function or command and press **f1**, use the a quotation mark (?) before the function or command, OR use 'help()'
  - The viewer tab is a spcae where certain types of interactive content of dynamic HTML outputs are displayed
  
  
  

# R Markdown

Why R Markdown?... R Markdown is a tool that allows a blend of R code with narrative text (like this!). 

**Markdown basics: syntax for formatting text**

YAML Header

- The YAML header in an R Markdown document is a section at the beginning of the file enclosed by three dashes (- - -). 
  - The YAML header is used to configure various settings for the R Markdown document, and it plays a crucial role in controlling the document's appearance and behavior when rendered.
  - Key elements are:
    - 'title' specifying the title of the document
    - 'author' specifying the author(s) of the document
    - 'output' specifying the desired output format, such as HTML, PDF, or word
    - Additional metadata can be added, such as table of contents (toc), and figure widths and heights.
    
HEADINGS AND SUBHEADINGS

- Headings serve as main titles or major section headings within a document and are added to the table of contents.
  - headings and subheadings are created by using hash symbols (#) and (##), respectively.  
    - Effective use of headings aids in document organization and navigation for both yourself and others (especially when you have thousands of lines of code).
    - keep headings concise AND descriptive and avoid adding additional styling (i.e., bold or italics).
    - Use headings and subheadings directly above chunks of code.
    
CODE CHUNKS

- Code chunks are fundamental elements in R Markdown documents that allow you to embed and execute R code within a document. 
  - Code chunks are enclosed by three backticks (```{r}) or by using the keyboard shortcut is **Ctrl + Alt + I**.
   - Options can also be included to control their behavior, such as silencing warnings (```{r warning = FALSE}) 
    -  or using (```{r include = FALSE} to omit the chunk from the rendered file.
- Using code chunks will break down your analysis into manageable sections.
  - Code within the chunk is executed when the R Markdown document is rendered ("Knit").The results of the code (output, plots, etc.) are displayed in the final document.
    - clicking on the "play" button on the top right area of the code chunk with execute only the one chunk.
    - pressing **Ctrl + Enter** will execute only the line you are on.
- The '**#**' character is also used to create comments *within a code chunk*. 
  - Comments are lines of text that are not executed as code; instead, they serve as annotations or explanations for the code. 
    - When used within a code chunk, comments are helpful for providing context, clarifying the purpose of the code, or adding explanatory notes.
    - It can also be used to hide code within the chunk if you don't want it to affect the final rendering

TEXT STYLING

- Text styling allows you to enhance the visual presentation of your document
  - *Adding asterisks around text will create italics*
  - **Adding double asterisks around text will create bold face font**
  - A par of tildes (~) will create subscripts (e.g., H~2~0)
  - A pair of carets (^) will create superscripts (e.g., Cu^2+^)
  - Block quotes can be added by using the greater-than symbol (>)

> "If we knew what it was we were doing, it wouldn't be called research"
>
> --- Albert Einstein 



  
# Creating strings, vectors, and dataframes

**Now that we've explored some formatting techniques, let's delve into the core of programming with R.**

In programming, a **string** is a sequence of characters, and it forms the backbone of many operations, from data manipulation to generating dynamic reports.

- A string in R is a sequence of characters which can be letters, numbers, symbols, or spaces.
  - Strings are created by using single or double quotes and can be assigned or named using the assignment operator '**<-**'. For example, 
  
  mystring <- "Hello world"
  
  
**Please keep in mind** 

- Everything is CASE-SENSITIVE; be careful when assigning names to data structures!  
- It is generally not recommended to have names that start with a number. 
  - While R allows column names to start with a number, it can lead to potential issues and may not work seamlessly with certain functions or packages. 


Also, when we render with R Markdown, we need to designate that it is written in the R language
  - We do this by placing our code inside a code chunk. Let's try it below.
  
```{r}
my_string <- "Hello World"

my_string
```


We can also combine, or concatenate strings to create new ones.
**Note:** pay attention to the Environment pane

```{r}
first <- "Austin"
first
last <- "Lien"
last

Name <- paste(first, last)
Name

```

Let's try another one.
```{r}
city <- "Crookston"
city
state <- "Minnesota"
state

location <- paste(city, state,
                  sep = ", ")
location

```


A **vector** is also a fundamental data structure in R that represents a one-dimensional array of elements

- Vectors are created using the '**c()**' function, which concatenates elements.
- Elements within a vector must be of the same data type (e.g., numeric, character, etc.)
  
Let's create some vectors below:

```{r}
names <- c("Alice", "Bob", "Charlie", "Derek", "Emily")
names

age <- c(31, 43, 28, 33, 27)
age

pronouns  <- c("She/Her", "He/Him", "They/Them", "He/Him", "She/Her")
pronouns
```

Now that we have created vectors, let's merge them into a data.frame

A **dataframe** is a two-dimensional data structure in R appearing as tables.

  - Dataframes consists of columns, each of which can be a different data type, arranged in rows
  - Essentially, they are collection of vectors, where each vector is a column in the data frame

```{r}
attendees <- data.frame(names, age, pronouns)

attendees
```

**Did you notice a new data structure appeared in the Environment Tab?**
 
- click on the new dataframe to view
- click on the blue arrow directly to the left of the dataframe name
  - Each variable is displayed with their name, type, and values.
  - Do you notice the $ symbol in front of the variables?
    - The '**$**' is used to extract specific columns or elements from a dataframe.
    
Let use the '$' to view the contents of the name column

```{r}
attendees$names
```

  
Now let's introduce **Factors**!

- A **factor** is a data structure used to represent distinct categories or levels.
- Most often, they are things like Treatments, Varieties, or Replications in an experiment

Let's change the pronouns column into factor.
- This code below will overwrite the pronouns column

```{r}
attendees$pronouns <- as.factor(attendees$pronouns)
```

 - Check in the environment, did anything change? Pronouns should now be a factor with 3 levels.

If we don't want to overwrite the column, we can also make a new one!

```{r}
attendees$gender_pronouns <- as.factor(attendees$pronouns)
```

 - We can also check out dataframe by using the **summary()** function
 
```{r}
summary(attendees)
```

We should now see an additional column in our dataframe identical to the pronouns column

*Remember, if you don't want the summary output to show up in your final rendering, we can always do this in the console pane below.*


# Installing and loading packages

Installing packages in R is necessary to access additional functions and capabilities not included in the base R installation.

- To install a package, use the install.packages() function, providing the name of the package in quotes.
  - for example, install.packages("tidyverse")
  - you can also install multiple packages at once using a vector, for example, install.packages(c("dplyr", "ggplot2", "tidyr"))
  - installed packages will remain in the R file and shouldn't need to be installed again until you update R to a new version. 
- Once installed, packages need to be loaded into the R session before their functions can be used.
- To load a package, use the library() function, providing the name of the package *without* quotes.
  - Loading is done each time you start a new R session or when you want to use functions from a specific package
  - It's common to install and load packages at the beginning of your script 
    - I often use ```{r warning = FALSE, include = FALSE} in the code chunk to omit the code from the rendered file
    

**Below is a list and short descriptions of packages I commonly use.**

- **library(readxl)**
  - to read .xlsx (Excel) files

- **library(tidyverse)**
  - loads all core tidyverse packages
    - **ggplot2** - for data visualization
    - **dplyr** - for data manipulation
    - **tidyr** - for data tidying
    - **readr** - for data import
    - **tibble** - for "re-imagining" the dataframe
  - These packages can be installed and loaded separately as well.

- **library(kableExtra)**
  - Provides additional styling in rendered tables

- **library(ggpubr)**
- for "publication ready" data visualization
  - also, I find it easier than ggplot2 to create line graphs and scatter plots

Aesthetic packages 

- library(RColorBrewer)
  - Color palettes for color-blind friendly visuals
  
- library(scales)
  - transformation of scales in data visualization 

- library(extrafont)
  - For using other fonts in data visualization
  - This can be a pain to download, especially on University computers, but maybe it has change since the last time I did it.

Statistic analysis packages

- library(agricolae)
  - For post-hoc tests (e.g., LSD or HSD) for general linear models
  - For split-plot, split-split-plot, and strip-plot ANOVA.

- library(lme4) OR
- library(lmerTest)
  - For Mix-model ANOVA and assigning random effects
    - equivalent to PROC MIXED or PROC GLIMMIX in SAS

- library (emmeans)
  - For estimated marginal means (i.e., Least-squares means)
      - equivalent to LSMEANS of PROC GLIMMIX in SAS
      
- library(multcomp)
  - For compact letter display of emmeans output

- library(rstatix)
  - Additional statistics and correlation matrices

library(MASS)
- For BOX-COX transformations and other statistics
  - I've only had to use this once, other transformations (e.g., log10) usually do the trick


# Bringing in our own dataset

**Now that we've covered the basics of R, including its syntax, variables, data structures, and the essentials of packages, it's time to put this knowledge into practice by working with real data.**

Before we delve into working with our dataset, let's make sure we're in the right place. The working directory is the folder where R will look for files by default. To set the working directory, we use the '**setwd()**' function.

Setting the working directory is an important step when working with datasets in R. The working directory is the folder where R looks for and saves files. By setting the working directory, you make it easier to read and write files as you can refer to them by their relative paths.

Determining the file path for setting the working directory depends on your operating system and the location of the folder you want to use. 

In RStudio you can also go to the 'session' menu, select 'set working directory', click 'choose directory', and navigate to the desired folder in the file dialog.

**However, I prefer to navigate to the folder on my computer where I've stored my dataset, or where I'd like to save any files generated during your R session.**

  - Click on the folder's address bar, and it will display the full path. You can copy this path.
- Use the **setwd()** function to specify the path to your chosen directory.
  - Be mindful of the slashes in your file path. Windows uses backslashes ( '\' ), and on macOS/Linux, use forward slashes ( '/' ).
  - **Make sure to change to forward slashes ( / ) for paths in R when using Windows.**
  - You can confirm that you've set the correct working directory by using the **getwd()** function.
  
 

```{r}
# setwd("C:/Users/lienx/Documents/2024-02-06 R Workshop")

setwd("G:/NWROC/SugarBeet_Pathology/R Workshop_2024_AKL/2024-02-06 Session")

getwd()
```

Now let's install and load the packages '**readxl**' and '**tidyverse**'

```{r}
# Install.packages('readxl')
# Install.packages('tidyverse')

library(readxl)
library(tidyverse)
``` 

Go to the **Files tab** in the Output pane. Do you see your Excel file? We can bring it into our environment using the '**read_excel()**' command from the readxl package

**Note:** To import tab-delimited filed (.csv) use the 'read.csv()' function

```{r}
Assay <- read_excel(("2024-02-06 Data Set.xlsx"), 
                      sheet = "Soil Assays")
```

Check the environment, do you see your data frame?

Once the data is loaded, we can explore it to understand its structure and content several functions to get an initial overview

- **head()**: displays the first few rows
- **summary()**: displays summary statistics 
- **str()**: displays the structure of the data

```{r}
head(Assay)

summary(Assay)

str(Assay)
```

Let's convert some of the variables to factors

- the **as.factor()** function automatically identifies unique categories or levels 
- the **factor()** function is often used to specify custom levels using the '**level**' argument and allows you to rename them with the '**labels**' argument
  - **Be advised**, levels and labels need to be the same length and order.
    - In addition, the levels will appear alphabetically, even numbers (i.e., 1, 10, 2, 3)
- the **ordered()** function can be used similar to factor() but it is used to create an ordered factor where levels have a meaningful order
- **Note**: the '**\n**' argument can be used to create additional lines for each variable.
  

```{r}
Assay$Rep <- as.factor(Assay$Rep)

Assay$Trmt <- factor(Assay$Trmt, 
                    levels = c('kab', 'tach'),
                    labels = c("Kabina", "Tachigaren"))

Assay$Soil <- as.factor(Assay$Soil)

Assay$Year <- ordered(Assay$Year,
                      levels = c('2023', '2024'),
                      labels = c('2022-\n2023', '2023-\n2024'))
```

# Creating a boxplot 

**Now let's make our first figure!**

We will use the ggplot2 package to compare the Root Rot Index (**TotalRRI**) among the different **Soil** and **Trmt** using the *ggplot()** and *geom_boxplot()* arguments.

But let's first break down the components of 'ggplot()'
- **ggplot(data = my_data, aes(x = X, y = Y))**: This initializes the plot and sets the data and aesthetic mappings.
  - **data**: specifies the dataframe containing the variables to be plotted.
  - **aes()**: Aesthetic mappings define how variables in the dataset are mapped to visual properties.
    - Here, '**x**', '**y**', and '**fill**' aesthetics are mapped to specific variables.
  
- The '**+**' operator is used for adding additional layers to a plot, allowing you to build up a complex plot step by step.
  -  **+ geom_boxplot()** :creates a boxplot.
      - **width**: Controls the width of the boxes in the plot.
      - **color**: Sets the color of the outlines of the boxes.
        - colors can be specified either by name (e.g.: “red”) or by hexadecimal code (e.g. : “#FF1234”)
      - **alpha**: Adjusts the transparency of the boxes.
  - **+ facet_grid()** OR **facet_wrap**: Creates faceted plots to display multiple subsets of data into single plot.
  - **+ labs()**: Sets the titles for the plot and axes.
  - **+ theme_light()**:Specifies the overall appearance of the plot.
  - **theme()**: customizes the appearance of the plot and allows modifications to various aspects, such as axis labels, text size, legend placement, and more.
  
Similar principles apply to other types of plots in ggplot2. As you gain more experience with ggplot2, you'll discover additional options for fine-tuning your visualizations.


```{r}
ggplot(data = Assay,
       aes(x=Soil, y = TotalRRI, fill = Trmt)) +
  
  geom_boxplot(width = 0.25, color = "black", alpha = 0.8) +
  
  facet_wrap(~ Year, ncol = 2) +
  
  labs(x = "Location",
       y = "Root Rot Index (0-100)",
       title = "Root Rot Indices of disease nursery soils by year",
       fill = "Seed Treatment") +
  
  theme_light() +
  
  theme(text = element_text(size = 15, 
                            face = "bold", 
                            color = "darkblue"),
        axis.text.x = element_text(size = 10, 
                                   face = "italic", 
                                   color = "forestgreen"),
        axis.title.x = element_blank(),
        plot.title = element_text(hjust = 0.5, vjust = 1),
        legend.position = "bottom",
        legend.background = element_rect(color = "black", 
                                         fill = "lightgray", 
                                         linewidth = 0.5),
        plot.background = element_rect(color = "black", 
                                       fill = NA, 
                                       linewidth = 2))
```










